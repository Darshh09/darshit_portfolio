import { promises as fs } from 'node:fs';
import path from 'node:path';

import { rimraf } from 'rimraf';
import { type Registry, registrySchema } from 'shadcn/schema';

// Dynamic imports to handle ESM module resolution with tsx in Node v22+
const { registry } = await import('../registry/index');

const REGISTRY_PATH = path.join(process.cwd(), 'src/__registry__');
const PUBLIC_REGISTRY_PATH = path.join(process.cwd(), 'public/r');

/**
 * Build src/__registry__/registry.autogenerated.json, src/__registry__/index.tsx
 * Thanks @shadcn/ui
 */
export async function buildRegistry(registry: Registry) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.mts
// Do not edit this file directly.

import React from "react";

export const Index: Record<string, any> = {`;
  for (const item of registry.items) {
    if (!Array.isArray(item.files) || !item.files?.length) {
      continue;
    }

    const componentPath = `@/registry/${item.files[0].path}`;

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ''}",
    type: "${item.type}",
    files: [${item.files.map((file) => {
      const filePath = `src/registry/${file.path}`;
      return `{
      path: "${filePath}",
      type: "${file.type}",
    }`;
    })}],${
      item.type === 'registry:example'
        ? `
    component: React.lazy(() => import("${componentPath}")),`
        : ''
    }
  },`;
  }

  index += `
}`;

  // Build /src/__registry__/registry.autogenerated.json
  const registryJSON = JSON.stringify(
    {
      $schema: 'https://ui.shadcn.com/schema/registry.json',
      name: 'darx',
      homepage: 'https://darshitdev.in/arts',
      items: registry.items
        .filter((item) => item.type !== 'registry:example')
        .map((item) => {
          return {
            ...item,
            files:
              item.files?.map((file) => {
                if (file.path.startsWith('src/')) {
                  return file;
                }

                return {
                  ...file,
                  path: `src/registry/${file.path}`,
                };
              }) ?? [],
          };
        }),
    },
    null,
    2
  );

  rimraf.sync(path.join(REGISTRY_PATH, 'registry.autogenerated.json'));
  await fs.writeFile(
    path.join(REGISTRY_PATH, 'registry.autogenerated.json'),
    registryJSON,
    'utf8'
  );

  // Build public registry
  rimraf.sync(path.join(PUBLIC_REGISTRY_PATH, 'registry.json'));
  await fs.writeFile(
    path.join(PUBLIC_REGISTRY_PATH, 'registry.json'),
    registryJSON,
    'utf8'
  );

  // Build individual component JSON files for shadcn CLI
  // These are required for namespaced registry access: @darx/component-name
  const components = registry.items.filter(
    (item) => item.type === 'registry:component'
  );

  for (const component of components) {
    if (!component.files || component.files.length === 0) {
      continue;
    }

    // Read file content for each file in the component
    const filesWithContent = await Promise.all(
      component.files.map(async (file) => {
        let filePath: string;
        const filePathStr = file.path;

        if (filePathStr.startsWith('src/')) {
          filePath = path.join(process.cwd(), filePathStr);
        } else {
          filePath = path.join(process.cwd(), 'src/registry', filePathStr);
        }

        try {
          const content = await fs.readFile(filePath, 'utf8');
          return {
            ...file,
            path: filePathStr.startsWith('src/')
              ? filePathStr
              : `src/registry/${filePathStr}`,
            content,
          };
        } catch (error) {
          console.warn(
            `Warning: Could not read file ${filePath} for component ${component.name}:`,
            error
          );
          return {
            ...file,
            path: filePathStr.startsWith('src/')
              ? filePathStr
              : `src/registry/${filePathStr}`,
          };
        }
      })
    );

    // Create individual component JSON file
    const componentJSON = {
      $schema: 'https://ui.shadcn.com/schema/registry-item.json',
      name: component.name,
      type: component.type,
      title: component.title,
      author: component.author || 'darx <darshit@darshitdev.in>',
      description: component.description,
      dependencies: component.dependencies || [],
      registryDependencies: component.registryDependencies || [],
      files: filesWithContent,
      docs: component.docs,
    };

    const componentFilePath = path.join(
      PUBLIC_REGISTRY_PATH,
      `${component.name}.json`
    );
    await fs.writeFile(
      componentFilePath,
      JSON.stringify(componentJSON, null, 2),
      'utf8'
    );
  }

  // Build /src/__registry__/index.tsx
  rimraf.sync(path.join(REGISTRY_PATH, 'index.tsx'));
  await fs.writeFile(path.join(REGISTRY_PATH, 'index.tsx'), index, 'utf8');
}

try {
  console.log('ðŸ’½ Building registry...');

  const result = registrySchema.safeParse(registry);

  if (!result.success) {
    console.error(result.error);
    process.exit(1);
  }

  await buildRegistry(result.data);

  console.log('âœ… Done!');
} catch (error) {
  console.error(error);
  process.exit(1);
}

